<!DOCTYPE html>
<html lang="english">
<head>
          <title>Jack McKew's Blog - Parallel Processing in Python</title>
        <meta charset="utf-8" />




    <meta name="tags" content="python" />

</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="https://jackmckew.dev/">Jack McKew's Blog <strong>Python enthusiast, electrical engineer and tinkerer</strong></a></h1>
        </header><!-- /#banner -->
        <nav id="menu"><ul>
            <li><a href="/archives.html">Archives</a></li>
            <li><a href="/categories.html">Categories</a></li>
            <li><a href="/tags.html">Tags</a></li>
            <li><a href="/sitemap.xml">Sitemap</a></li>
            <li><a href="https://jackmckew.dev/pages/contact.html">Contact</a></li>
            <li><a href="https://jackmckew.dev/pages/cv-professional.html">CV/Professional</a></li>
            <li><a href="https://jackmckew.dev/category/android.html">Android</a></li>
            <li><a href="https://jackmckew.dev/category/book-reviews.html">Book Reviews</a></li>
            <li><a href="https://jackmckew.dev/category/data-science.html">Data Science</a></li>
            <li><a href="https://jackmckew.dev/category/engineering.html">Engineering</a></li>
            <li><a href="https://jackmckew.dev/category/engineering-python.html">Engineering, Python</a></li>
            <li><a href="https://jackmckew.dev/category/machine-learning.html">Machine Learning</a></li>
            <li><a href="https://jackmckew.dev/category/principles.html">Principles</a></li>
            <li class="active"><a href="https://jackmckew.dev/category/python.html">Python</a></li>
            <li><a href="https://jackmckew.dev/category/python-data-science.html">Python, Data Science</a></li>
            <li><a href="https://jackmckew.dev/category/python-engineering.html">Python, Engineering</a></li>
            <li><a href="https://jackmckew.dev/category/python-principles.html">Python, Principles</a></li>
            <li><a href="https://jackmckew.dev/category/software-development.html">Software Development</a></li>
            <li><a href="https://jackmckew.dev/category/software-development-data-science.html">Software Development, Data Science</a></li>
        </ul></nav><!-- /#menu -->
<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="https://jackmckew.dev/parallel-processing-in-python.html" rel="bookmark"
         title="Permalink to Parallel Processing in Python">Parallel Processing in Python</a></h2>
 
  </header>
  <footer class="post-info">
    <time class="published" datetime="2019-06-07T06:30:00+10:00">
      Fri 07 June 2019
    </time>
    <address class="vcard author">
      By           <a class="url fn" href="https://jackmckew.dev/author/jack-mckew.html">Jack McKew</a>
    </address>
    <div class="category">
        Category: <a href="https://jackmckew.dev/category/python.html">Python</a>
    </div>
    <div class="tags">
        Tags:
            <a href="https://jackmckew.dev/tag/python.html">python</a>
    </div>
  </footer><!-- /.post-info -->
  <div class="entry-content">
    <p>Parallel processing is a mode of operation where the task is executed simultaneously in multiple processors in the same computer. The purpose of this is intended to reduce the overall processing time, however, there is often overhead between communicating processes. For small tasks, the overhead is detrimental to the length of processing, increasing the overall time taken.</p>
<p>For this post we will be using the multiprocessing package in Python. Multiprocessing is apart of the standard library within Python and is a package that supports spawning processes using an API similar to the threading module (also apart of the standard library). The main benefit of the multiprocessing package, is that it disregards the global interpreter lock (GIL), by using sub processes instead of threads.</p>
<p>The number of processors or threads in your computer dictates the maximum number of processes you can run at a time. To add flexibility to your program when it may be run across multiple machines, it is good practice to make use of the cpu_count() function apart of the multiprocessing, as shown below (please note f strings were only introduced in Python 3.6).</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="kn">as</span> <span class="nn">mp</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Maximum number of processes: {mp.cpu_count()}&quot;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>In parallel processing, there are two types of execution: Synchronous and Asynchronous. Synchronous meaning where the processes are completed in the same order in which it was started, such that, the output is (normally) in order. While asynchronous means the processes can be in any order, and while the output can be mixed, is usually computed faster.</p>
<p>Within multiprocessing there are 2 main classes that you will use for parallel processing: Pool &amp; Process. The two classes are intended to be used in completely different scenarios, but still utilize parallel processing. Pool is beneficial for when you have a long list that need to be processed and combined back together at the end. Process is beneficial for when you need multiple functions running simultaneously, albeit not the same.</p>
<h3>The Pool Class</h3>
<p>The pool class has four methods that are particular useful:</p>
<ul>
<li>Pool.apply</li>
<li>Pool.map</li>
<li>Pool.apply_async</li>
<li>Pool.map_async</li>
</ul>
<p>Before we tackle the asynchronous variants of the pool methods (async suffix). Here is a simple example using Pool.apply and Pool.map. We initialize the number of processes to however many is available or the maximum of the system.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">power_n_minus_1</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">**</span><span class="n">value</span><span class="o">-</span><span class="mi">1</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">mp</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">())</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">pool</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">power_n_minus_1</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
    <span class="k">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>With the results being: [1, 2, 9, 64] or 1\^0, 2\^1,3\^2,4\^3. This can also be achieved similarly with Pool.map.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">power_n_minus_1</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">**</span><span class="n">value</span><span class="o">-</span><span class="mi">1</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">mp</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">())</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">power_n_minus_1</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Both of these will lock the main program that is calling them until all processes in the pool are finished, use this if you want to obtain results in a particular order. However if you don't care about the order and want to retrieve results as soon as they finished, then use the async variant.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">power_n_minus_1</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">**</span><span class="n">value</span><span class="o">-</span><span class="mi">1</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">mp</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">())</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">power_n_minus_1</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<h3>The Process Class</h3>
<p>The process class is the most basic approach to parallel processing from multiprocessing package. Here we will use a simple queue function to generate 10 random numbers in parallel.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="kn">as</span> <span class="nn">mp</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="n">output</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">rand_number</span><span class="p">(</span><span class="n">lower_limit</span><span class="p">,</span><span class="n">upper_limit</span><span class="p">,</span><span class="n">output</span><span class="p">):</span>
    <span class="n">output</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">lower_limit</span><span class="p">,</span><span class="n">upper_limit</span><span class="p">))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">processes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">rand_number</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">101</span><span class="p">,</span><span class="n">output</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
        <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
        <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">output</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>With the result being: [76, 40, 76, 27, 64, 94, 30, 71, 70, 40].</p>
<p>By utilizing the multiprocessing package in Python or parallel computing concepts in general, you will now be able to dramatically increase computation times (for large processes).</p>
  </div><!-- /.entry-content -->
</section>
        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->
        </footer><!-- /#contentinfo -->
</body>
</html>