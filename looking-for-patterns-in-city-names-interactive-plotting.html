<!DOCTYPE html>
<html lang="english">
<head>
          <title>Jack McKew's Blog - Looking for Patterns in City Names & Interactive Plotting</title>
        <meta charset="utf-8" />




    <meta name="tags" content="python" />
    <meta name="tags" content="datascience" />

</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="https://jackmckew.dev/">Jack McKew's Blog <strong>Python enthusiast, electrical engineer and tinkerer</strong></a></h1>
        </header><!-- /#banner -->
        <nav id="menu"><ul>
            <li><a href="/archives.html">Archives</a></li>
            <li><a href="/categories.html">Categories</a></li>
            <li><a href="/tags.html">Tags</a></li>
            <li><a href="/sitemap.xml">Sitemap</a></li>
            <li><a href="https://jackmckew.dev/pages/contact.html">Contact</a></li>
            <li><a href="https://jackmckew.dev/pages/cv-professional.html">CV/Professional</a></li>
            <li><a href="https://jackmckew.dev/category/android.html">Android</a></li>
            <li><a href="https://jackmckew.dev/category/book-reviews.html">Book Reviews</a></li>
            <li><a href="https://jackmckew.dev/category/data-science.html">Data Science</a></li>
            <li><a href="https://jackmckew.dev/category/engineering.html">Engineering</a></li>
            <li><a href="https://jackmckew.dev/category/engineering-python.html">Engineering, Python</a></li>
            <li><a href="https://jackmckew.dev/category/machine-learning.html">Machine Learning</a></li>
            <li><a href="https://jackmckew.dev/category/principles.html">Principles</a></li>
            <li><a href="https://jackmckew.dev/category/python.html">Python</a></li>
            <li class="active"><a href="https://jackmckew.dev/category/python-data-science.html">Python, Data Science</a></li>
            <li><a href="https://jackmckew.dev/category/python-engineering.html">Python, Engineering</a></li>
            <li><a href="https://jackmckew.dev/category/python-principles.html">Python, Principles</a></li>
            <li><a href="https://jackmckew.dev/category/software-development.html">Software Development</a></li>
            <li><a href="https://jackmckew.dev/category/software-development-data-science.html">Software Development, Data Science</a></li>
        </ul></nav><!-- /#menu -->
<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="https://jackmckew.dev/looking-for-patterns-in-city-names-interactive-plotting.html" rel="bookmark"
         title="Permalink to Looking for Patterns in City Names & Interactive Plotting">Looking for Patterns in City Names & Interactive Plotting</a></h2>
 
  </header>
  <footer class="post-info">
    <time class="published" datetime="2019-08-16T06:30:00+10:00">
      Fri 16 August 2019
    </time>
    <address class="vcard author">
      By           <a class="url fn" href="https://jackmckew.dev/author/jack-mckew.html">Jack McKew</a>
    </address>
    <div class="category">
        Category: <a href="https://jackmckew.dev/category/python-data-science.html">Python, Data Science</a>
    </div>
    <div class="tags">
        Tags:
            <a href="https://jackmckew.dev/tag/python.html">python</a>
            <a href="https://jackmckew.dev/tag/datascience.html">datascience</a>
    </div>
  </footer><!-- /.post-info -->
  <div class="entry-content">
    <p>Recently, I was traveling around New Zealand, and noticed in the Maori language they use letters back to back a lot like in the original Maori name for Stratford ("whakaahurangi"). So as any normal person does, I thought, well what town has the most repeated letters, and the idea for this blog post was born. Before we get into the nitty gritty, here is the output of the analysis!</p>
<p>{% notebook looking-for-patterns-in-city-names-interactive-plotting/NZ_City_Letter_Analysis.ipynb cells[24:25] %}</p>
<p>Firstly, we have to find a dataset of all the town names, and I found a database of all world cities names hosted on Kaggle here: <a href="https://www.kaggle.com/max-mind/world-cities-database">https://www.kaggle.com/max-mind/world-cities-database</a>.</p>
<h2 id="Get-the-data!">Get the data!</h2>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># data source https://www.kaggle.com/max-mind/world-cities-database</span>
<span class="n">cities_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;./data/worldcitiespop.csv&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">quotechar</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)</span>
<span class="n">cities_df</span> <span class="o">=</span> <span class="n">cities_df</span><span class="p">[</span><span class="n">cities_df</span><span class="p">[</span><span class="s1">&#39;Country&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;nz&quot;</span><span class="p">]</span>
</pre></div>
</td></tr></table>

<p>After inspecting the data of this data set, we're able to filter out to look at just New Zealand with the prefix of "nz" in the Country column. It must be noted that this data set represents the names of the towns currently, and not the original Maori names (more on this will be covered in a later post). Now we want to extract the town names out of the dataframe with the ones we want to analyze. For ease later on, we will extract this as a dictionary, such that we can assign the value of each to the count of each letter.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">nz_cities</span> <span class="o">=</span> <span class="n">cities_df</span><span class="p">[</span><span class="n">cities_df</span><span class="p">[</span><span class="s1">&#39;Country&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;nz&quot;</span><span class="p">][</span><span class="s1">&#39;AccentCity&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="n">nz_dict</span> <span class="o">=</span> <span class="p">{</span> <span class="n">i</span> <span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nz_cities</span> <span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Now we will create an ordered dictionary with the help from the collections package which will store the values of the count for each letter in the town name.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">letters</span> <span class="o">=</span> <span class="s1">&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</span>
<span class="n">lcount</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">OrderedDict</span><span class="p">([(</span><span class="n">l</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">letters</span><span class="p">]))</span>
</pre></div>
</td></tr></table>

<p>Now it's time for the data crunch. To count how many times a letter repeats in a town name we follow these steps:</p>
<ul>
<li>we create a for loop, to loop through all the city names in the table,</li>
<li>initialise an ordered dictionary similar to above for each city in the value field of that town's dictionary entry</li>
<li>loop through each letter in the town name</li>
<li>check if the letter appears in our letter dictionary (mainly to not count spaces),</li>
<li>Then if the letter does appear, increment the value for that letter by 1.</li>
</ul>
<p>This results in a dictionary for each town name, with the count of repeated letters.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">city</span> <span class="ow">in</span> <span class="n">nz_cities</span><span class="p">:</span>
    <span class="n">nz_dict</span><span class="p">[</span><span class="n">city</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">OrderedDict</span><span class="p">([(</span><span class="n">l</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">letters</span><span class="p">]))</span>
    <span class="n">city_dict</span> <span class="o">=</span> <span class="n">nz_dict</span><span class="p">[</span><span class="n">city</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">city</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="n">letters</span><span class="p">:</span>
            <span class="n">city_dict</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</td></tr></table>

<p>Hooray! Now we have all the data we need broken down and ready for analysis. To help ease the analysis and make it more readable for a human, we convert from our nested dictionaries to a pandas dataframe and transpose it such that we have the town name as the index, the letters as the column and the count of that letter as the values.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">total_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">nz_dict</span><span class="p">)</span>
<span class="n">total_df</span> <span class="o">=</span> <span class="n">total_df</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</td></tr></table>

<p>Now we want to find which of these names have the maximum count for any particular letter and store it in a summary dataframe. It is to be noted that we could use the pivot function with aggregate types, however, I have not figured a nice way to do this yet. If you do know a nicer way to determine this, please let me know.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">summary_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">summary_df</span><span class="p">[</span><span class="s1">&#39;City_Name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_df</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>
<span class="n">summary_df</span><span class="p">[</span><span class="s1">&#39;Count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">total_df</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>Now by using the equivalent of an index-match in excel which you can read more about here (<a href="https://towardsdatascience.com/name-your-favorite-excel-function-and-ill-teach-you-its-pandas-equivalent-7ee4400ada9f">https://towardsdatascience.com/name-your-favorite-excel-function-and-ill-teach-you-its-pandas-equivalent-7ee4400ada9f</a>). Admittedly, we could've made the join earlier, but since I use index-match so often in Excel, I wanted to learn how to do the same in pandas. This is achieved by using the map function (which is the equivalent of the index), but by using the index of another dataframe as the argument (the match function), we can rejoin the data set by matching the city name from our original data set.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">summary_df</span><span class="p">[</span><span class="s1">&#39;Latitude&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">summary_df</span><span class="p">[</span><span class="s1">&#39;City_Name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cities_df</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;AccentCity&#39;</span><span class="p">])[</span><span class="s1">&#39;Latitude&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span> <span class="o">*</span> <span class="n">scale</span>
<span class="n">summary_df</span><span class="p">[</span><span class="s1">&#39;Longitude&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">summary_df</span><span class="p">[</span><span class="s1">&#39;City_Name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">cities_df</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;AccentCity&#39;</span><span class="p">])[</span><span class="s1">&#39;Longitude&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span> <span class="o">*</span> <span class="n">scale</span>
</pre></div>
</td></tr></table>

<p>Now we have a dataframe that contains:</p>
<ul>
<li>an index of the letters,</li>
<li>the town name with the most repeated letters,</li>
<li>the count of the letters within the name,</li>
<li>the longitude and latitude of the town</li>
</ul>
<p>For plotting with <a href="https://bokeh.pydata.org/en/latest/">Bokeh</a> on a basemap, we need to convert from longitude &amp; latitude to easting and northing. To do this we use the pyproj package to make this very simple.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">LongLat_to_EN</span><span class="p">(</span><span class="nb">long</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">easting</span><span class="p">,</span> <span class="n">northing</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span>
        <span class="n">Proj</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="s1">&#39;epsg:4326&#39;</span><span class="p">),</span> <span class="n">Proj</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="s1">&#39;epsg:3857&#39;</span><span class="p">),</span> <span class="nb">long</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">easting</span><span class="p">,</span> <span class="n">northing</span>
    <span class="k">except</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
</pre></div>
</td></tr></table>

<p>This function can be used to generate the easting and northing for every town from it's longitude &amp; latitude and add it to the dataframe.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">summary_df</span><span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">],</span> <span class="n">summary_df</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">summary_df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">LongLat_to_EN</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;Longitude&#39;</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;Latitude&#39;</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Finally, it's time to plot our findings on a map. Before we initialise the map in <a href="https://bokeh.pydata.org/en/latest/">Bokeh</a>, for most plots, data tables and more in <a href="https://bokeh.pydata.org/en/latest/">Bokeh</a>, we need to put it in the <a href="https://bokeh.pydata.org/en/latest/docs/reference/models/sources.html">ColumnDataSource</a> form. We also initialise the interactivity when the user hovers over the data points on the plot.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">source</span> <span class="o">=</span> <span class="n">ColumnDataSource</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                        <span class="n">longitude</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">summary_df</span><span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">]),</span> 
                        <span class="n">latitude</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">summary_df</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">]),</span>
                        <span class="n">sizes</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">summary_df</span><span class="p">[</span><span class="s1">&#39;Count&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">),</span>
                        <span class="n">lettercount</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">summary_df</span><span class="p">[</span><span class="s1">&#39;Count&#39;</span><span class="p">]),</span>
                        <span class="n">city_name</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">summary_df</span><span class="p">[</span><span class="s1">&#39;City_Name&#39;</span><span class="p">]),</span>
                        <span class="n">letters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">summary_df</span><span class="o">.</span><span class="n">index</span><span class="p">)))</span>

<span class="n">hover</span> <span class="o">=</span> <span class="n">HoverTool</span><span class="p">(</span><span class="n">tooltips</span><span class="o">=</span><span class="p">[</span>
    <span class="p">(</span><span class="s2">&quot;Repeated Letter&quot;</span> <span class="p">,</span> <span class="s2">&quot;@letters&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;City Name&quot;</span><span class="p">,</span> <span class="s2">&quot;@city_name&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;Count&quot;</span><span class="p">,</span><span class="s2">&quot;@lettercount&quot;</span><span class="p">)</span>

<span class="p">])</span>
</pre></div>
</td></tr></table>

<p>Finally time for the plot! Now admittedly, I haven't found an easy way to find the limits of the graph, so this was made with a lot of trial and error (If you know a better way, please let me know!).</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">figure</span><span class="p">(</span><span class="n">x_range</span><span class="o">=</span><span class="p">(</span><span class="mi">20000000</span><span class="p">,</span><span class="mi">17900000</span><span class="p">),</span> <span class="n">y_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">6000000</span><span class="p">,</span><span class="o">-</span><span class="mi">4000000</span><span class="p">),</span><span class="n">x_axis_type</span><span class="o">=</span><span class="s2">&quot;mercator&quot;</span><span class="p">,</span> <span class="n">y_axis_type</span><span class="o">=</span><span class="s2">&quot;mercator&quot;</span><span class="p">,</span><span class="n">tools</span><span class="o">=</span><span class="p">[</span><span class="n">hover</span><span class="p">,</span> <span class="s1">&#39;wheel_zoom&#39;</span><span class="p">,</span><span class="s1">&#39;save&#39;</span><span class="p">])</span>
<span class="n">p</span><span class="o">.</span><span class="n">add_tile</span><span class="p">(</span><span class="n">CARTODBPOSITRON</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span>
         <span class="n">y</span><span class="o">=</span><span class="s1">&#39;latitude&#39;</span><span class="p">,</span> 
         <span class="n">size</span><span class="o">=</span><span class="s1">&#39;sizes&#39;</span><span class="p">,</span>
         <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span>
         <span class="n">line_color</span><span class="o">=</span><span class="s2">&quot;#FF0000&quot;</span><span class="p">,</span> 
         <span class="n">fill_color</span><span class="o">=</span><span class="s2">&quot;#FF0000&quot;</span><span class="p">,</span>
         <span class="n">fill_alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
</pre></div>
</td></tr></table>
  </div><!-- /.entry-content -->
</section>
        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->
        </footer><!-- /#contentinfo -->
</body>
</html>